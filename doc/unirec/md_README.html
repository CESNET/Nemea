<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UniRec: UniRec</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UniRec
   &#160;<span id="projectnumber">2.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">UniRec </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview </h2>
<p>UniRec is a data format for storage and transfer of simple unstructured records, i.e. sets of key-value pairs with a fixed set of keys. A record in UniRec format is similar to a C structure but it can be defined at run-time. It thus brings possibility to dynamically create structures in a statically typed language.</p>
<p>The main advantage of UniRec is extremely fast access to fields of a record. No parsing is needed, the fields are accessed directly from the record, almost as in a plain C struct.</p>
<p>In comparison with access to a struct member, just one additional memory access is needed in order to find position of the field in the record. This access is to a small table which easily fits into a CPU cache.</p>
<p>To create an UniRec record, a user first needs to specify a set of fields and their types - a template. Then a memory for the record is allocated and field values can be set using simple macros.</p>
<p>NOTE: The following text describes UniRec as used in the C or C++ language.</p>
<h3>Simplified example:</h3>
<div class="fragment"><div class="line">// Create a template with three fields (their types must be defined earlier)</div><div class="line">ur_template_t *tmplt = ur_create_template(&quot;FIELD1,FIELD2,FIELD3&quot;, NULL);</div><div class="line"></div><div class="line">// Create a record with that template</div><div class="line">void *record = ur_create_record(tmplt, 0);</div><div class="line"></div><div class="line">// Set values of fields</div><div class="line">ur_set(tmplt, record, F_FIELD1, 1);</div><div class="line">ur_set(tmplt, record, F_FIELD2, 234);</div><div class="line">ur_set(tmplt, record, F_FIELD3, 56);</div><div class="line"></div><div class="line">// Read values of the record and print them to standard output</div><div class="line">printf(&quot;%i %i %i\n&quot;,</div><div class="line">   ur_get(tmplt, record, F_FIELD1),</div><div class="line">   ur_get(tmplt, record, F_FIELD2),</div><div class="line">   ur_get(tmplt, record, F_FIELD3),</div><div class="line">);</div></div><!-- fragment --><p>The example states that the types of the fields must be defined before a template can be created. If names and types of the fields are known at compile-time, they can be defined at the beginning of a *.c file as in the following example: </p><div class="fragment"><div class="line">// Specify which fields will be used in the code and what are their types</div><div class="line">UR_FIELDS(</div><div class="line">   int32 FIELD1,</div><div class="line">   int32 FIELD2,</div><div class="line">   int32 FIELD3,</div><div class="line">)</div></div><!-- fragment --><p> If the set of fields and their types is not known in advance, they may also be defined at run-time. However, access to such fields is then a little more complicated due to limitations of statically types languages (if a compiler doesn't know the type of a field, it can't create a set of instructions to read from or write into it).</p>
<h2>UniRec data types </h2>
<p>An UniRec field may have one of the following types:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name  </th><th class="markdownTableHeadNone">size  </th><th class="markdownTableHeadNone">description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int8  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">8bit singed integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">int16  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">16bit singed integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int32  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">32bit singed integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">int64  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">64bit singed integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">8bit unsigned integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint16  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">16bit unsigned integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint32  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">32bit unsigned integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint64  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">64bit unsigned integer   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">A single ASCII character   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">Single precision floating point number (IEEE 754)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">Double precision floating point number (IEEE 754)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">ipaddr  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">Special type for IPv4/IPv6 addresses, see below for details   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">macaddr  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">Special type for MAC address, see below for details   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">time  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">Special type for precise timestamps, see below for details   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Variable-length array of (mostly) printable characters   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">bytes  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Variable-length array of bytes (not expected to be printable characters)   </td></tr>
</table>
<p>Types "string" and "bytes" are the same from a machine point of view (both are of type char[] in C), the only difference is their semantics. When printing as text, "string" is usually printed directly as ASCII or UTF-8 string, "bytes" is rather interpreted as binary data and printed in hex.</p>
<p>A terminating null character ('\0') SHOULD NOT be included at the end of "string" values since this is specific for the C language and data in UniRec should be independent of a programming language.</p>
<h3>ipaddr type</h3>
<p>Structure to store both IPv4 and IPv6 addresses and associated functions.</p>
<h3>macaddr type</h3>
<p>Structure to store MAC address and associated functions.</p>
<h3>time type</h3>
<p>Structure to store timestamps and associated types, macros and function.</p>
<h2>Field names </h2>
<p>Name of field may be any string matching the regular expression [A-Za-z][A-Za-z0-9_]* with the following limitations:</p><ul>
<li>It SHOULD NOT end with "_T" as this is reserved in C implementation for symbolic constants storing the type of a field.</li>
</ul>
<p>It is RECOMMENDED that all field names are uppercase.</p>
<h2>Physical record layout </h2>
<p>An UniRec record consists of field values put one after another in a specific order. There is no header. Information about the template and the size of the record must be provided by other means.</p>
<p>The layout of a record is given only by its template (specifying a set of fields and their types) and the following rules.</p>
<p>A record is divided into three sections:</p><ol type="1">
<li>Values of all fixed-length fields</li>
<li>Meta-information about variable-length fields</li>
<li>Data of variable-length fields</li>
</ol>
<p>Fixed-length fields in the first section are sorted by their size from largest to smallest. Fields with the same size are sorted alphabetically by their name.</p>
<p>The second section contains two 16bit numbers for each variable-length field - offset of the beginning of the field's data and length of the data (in bytes). The offset is counted from the beginning of the record.</p>
<p>The meta-information fields are sorted alphabetically by the field names.</p>
<p>The third section contains data of variable-length fields in an arbitrary order. The data of variable-length fields SHOULD be placed immediately one after another. There SHOULD be NO "empty spaces" between them and data of the fields SHOULD NOT overlap.</p>
<p>The first two sections are called the "fixed-length part" of a record, since their total size is always the same and all data are present on fixed offsets (for a given template). The last section is called "variable-length part" because its total length as well as position of individual fields may be different in each record.</p>
<h3>Example</h3>
<p>The following picture shows layout of a record containing information about a HTTP connection. The template of this record contains the following fields: ipaddr SRC_IP, ipaddr DST_IP, uint16 SRC_PORT, uint16 DST_PORT, uint8 PROTOCOL, uint8 TCP_FLAGS, uint32 PACKETS, uint32 BYTES, uint16 HTTP_RSP_CODE, string HTTP_URL, string HTTP_USER_AGENT</p>
<div class="fragment"><div class="line">byte      0       1       2       3</div><div class="line">      +-------+-------+-------+-------+</div><div class="line"> 0    |                               |</div><div class="line"> 4    |            DST_IP             |</div><div class="line"> 8    |                               |</div><div class="line">12    |                               |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">16    |                               |</div><div class="line">20    |            SRC_IP             |</div><div class="line">24    |                               |</div><div class="line">28    |                               |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">32    |             BYTES             |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">36    |            PACKETS            |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">40    |   DST_PORT    | HTTP_RSP_CODE |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">44    |   SRC_PORT    | PROTO | TCP_F |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">48    | HTTP_URL(off) | HTTP_URL(len) |</div><div class="line">      +-------+-------+-------+-------+</div><div class="line">52    | HTTP_USER(off)| HTTP_USER(len)|   fixed-length</div><div class="line">      +-------+-------+-------+-------+   -----------------</div><div class="line">56    |         HTTP_URL (data)       |   variable-length part</div><div class="line">      +                       +-------+</div><div class="line">60    |                       |       |</div><div class="line">      +-------+-------+-------+       +</div><div class="line">64    |     HTTP_USER_AGENT (data)    |</div><div class="line">      +               +-------+-------+</div><div class="line">68    |               |</div><div class="line">      +-------+-------+</div></div><!-- fragment --><h3>Endianness</h3>
<p>All values, except IP and MAC addresses, are in little endian. IP and MAC addresses are treated rather as sequences of bytes than numbers, so they are left in network order, i.e. big-endian (however, they are encapsulated in a special data type and shouldn't be accessed directly so the internal format should be needed to know).</p>
<h3>Maximal record length</h3>
<p>Maximal length of the record is limited to 65534 (2^16 - 2) bytes.</p>
<h3>Template definition</h3>
<p>Templates are usually defined by a string enumerating all the fields in the template, using comma (',') as a separator of field names. Order of field names in such string is not important (since physical order of fields is given by the rules above).</p>
<h1>C library interface </h1>
<h2>Types and structures </h2>
<p>Types, enums and structures defined in <a class="el" href="unirec_8h.html" title="Definition of UniRec structures and functions. ">unirec.h</a>. </p><div class="fragment"><div class="line">enum ur_field_type {</div><div class="line">   UR_TYPE_INT8,</div><div class="line">   UR_TYPE_INT16,</div><div class="line">   UR_TYPE_INT32,</div><div class="line">   UR_TYPE_INT64,</div><div class="line">   UR_TYPE_UINT8,</div><div class="line">   UR_TYPE_UINT16,</div><div class="line">   UR_TYPE_UINT32,</div><div class="line">   UR_TYPE_UINT64,</div><div class="line">   UR_TYPE_CHAR,</div><div class="line">   UR_TYPE_FLOAT,</div><div class="line">   UR_TYPE_DOUBLE,</div><div class="line">   UR_TYPE_IP,</div><div class="line">   UR_TYPE_MAC,</div><div class="line">   UR_TYPE_TIME,</div><div class="line">   UR_TYPE_STRING,</div><div class="line">   UR_TYPE_BYTES,</div><div class="line">};</div></div><!-- fragment --><p> An enum value for each of the UniRec types.</p>
<h4>ur_field_id_t</h4>
<p>Unsigned integer type for holding field IDs. IMPLEMENTATION NOTE: ur_field_id_t = uint16_t</p>
<h4><a class="el" href="unirec_8h.html#structur__template__t" title="UniRec template. It contains a table mapping a field to its position in an UniRec record...">ur_template_t</a></h4>
<p>A structure defining an UniRec template. It contains information about which fields are present in a record with that template and how to access them. For user this is a black box, it is not needed to access the structure's members directly.</p>
<h4>ur_iter_t</h4>
<p>Iterator type used by ur_iter_fields function</p>
<h4>UR_ITER_BEGIN</h4>
<h4>UR_ITER_END</h4>
<p>Constants used for iteration over fields in a template, see ur_iter_fields function for details.</p>
<h4>UR_MAX_SIZE = 65535</h4>
<p>Maximal size of an UniRec record.</p>
<h2>Public functions and macros </h2>
<p>### Definition of statically-known UniRec fields. </p><div class="fragment"><div class="line">UR_FIELDS(type name [, type name [, ...] ])</div></div><!-- fragment --><p> This macro allows to define fields used in the program and their types at compile-time. This allows to access such fields in UniRec records more easily and efficiently.</p>
<p>This macro should be used in the beginning of each translation unit (i.e. a *.c file) if the fields used (or at least some of them) are known at compile-time.</p>
<p>Parameters:</p><ul>
<li>"name" may be any string matching the following regular expression: [A-Za-z][A-Za-z0-9_]* with the following exceptions:<ul>
<li>It must not be the same as a keyword in C/C++ or another identifier used in the source codes. To avoid collisions with other identifiers in the UniRec library, do not use identifiers beginning with "UR\_" or "ur\_"</li>
<li>It must not end with _T (as this is reserved for constants specifying types)</li>
<li>It is RECOMMENDED that all field names are upper case.</li>
</ul>
</li>
<li>"type" is one of the types specified in "format specification - data types".</li>
</ul>
<p>There MAY be a comma after the last field name. Also, there MAY be a semicolon after the closing parenthesis at the end of the macro.</p>
<p>#### Example: </p><div class="fragment"><div class="line">UR_FIELDS(</div><div class="line">  ipaddr   SRC_IP,</div><div class="line">  ipaddr   DST_IP,</div><div class="line">  uint16   SRC_PORT,</div><div class="line">  uint16   DST_PORT,</div><div class="line">  uint8    PROTO,</div><div class="line">)</div></div><!-- fragment --><p> This macro generates code allowing to use the defined fields in ur_get, ur_set and other macros which need symbolic constants to access the fields.</p>
<p>For each field specified by this macro, a CPP macro is defined with <code>F_</code> prefix in the name and a value of a unique numeric ID. Also, a constant F_name_T is defined with a value of the field's type (as defined in ur_field_type enum). Other internal variables and structures are defined.</p>
<p>If there are more than one translation unit accessing UniRec fields, the same set of fields MUST be defined using UR_FIELDS in each of them.</p>
<p>### Cleanup of all internal structures. </p><div class="fragment"><div class="line">int ur_finalize()</div></div><!-- fragment --><p> This function has to be called after all UniRec functions and macros invocations if there were some fields defined at run-time. Otherwise this function does not have any effect, because nothing has been allocated. The function is called typically during a cleanup phase before the program's end.</p>
<p>No UniRec function or macro can be called after a call to ur_finalize.</p>
<p>### Run-time definition of a field </p><div class="fragment"><div class="line">int ur_define_field(const char *name, ur_field_type type)</div></div><!-- fragment --><p> This function allows to define a field at run-time.</p>
<p>Parameters: "name" - name of the new field, see description of UR_FIELDS for rules on field names. "type" - type of the new field.</p>
<p>If a field with the same name already exists in the internal table of defined fields and "type" is the same as the one in the table, the function just returns the ID of the field. If types does not match, a UR_E_TYPE_MISMATCH error code is returned.</p>
<p>If no field with "name" is present in the table of fields, a new entry is created with a new unique ID and the given name and type of the field. The new ID is returned.</p>
<p>Returns:</p><ul>
<li>ID of a field with the given name if no error occurs.</li>
<li>UR_E_TYPE_MISMATCH if a field with the given name is already defined with a different type.</li>
<li>UR_E_INVALID_NAME if the name is not a valid field name.</li>
<li>UR_E_INVALID_TYPE if the type is not one of the values of enum ur_field_type.</li>
<li>UR_E_MEMORY if memory allocation error occurred.</li>
</ul>
<p>All error codes returned by this function are negative integers, ID is always non-negative.</p>
<p>If this function is used in a program, the function <a class="el" href="example__unirec_8c.html#a27c079b5e81042d3a6abe210afc17124">ur_finalize()</a> has to be called after all UniRec functions and macros invocations.</p>
<p>NOTE: It is not necessary to define fields which were defined by UR_FIELDS. It is recommended to define all fields statically by UR_FIELDS if possible. This function is present only for cases when field names and/or types are not known until run-time.</p>
<p>NOTE: Fields defined by this function can be accessed using their numeric IDs only. Symbolic CPP macros are not defined, of course.</p>
<h3>Run-time definition of a set of fields</h3>
<div class="fragment"><div class="line">int ur_define_set_of_fields(const char *ifc_data_fmt);</div></div><!-- fragment --><p>This function allows to define sef of fields at run-time.</p>
<p>Define new UniRec fields at run-time. It adds new fields into existing structures. If the field already exists and type is equal nothing will happen. If the type is not equal an error will be returned.</p>
<p>Parameters: "fc_data_fmt" - String containing types and names of fields delimited by comma. Example ifc_data_fmt: "uint32 FOO,uint8 BAR,float FOO2"</p>
<p>Returns:</p><ul>
<li>UR_OK on success</li>
<li>UR_E_MEMORY if there is an allocation problem.</li>
<li>UR_E_INVALID_NAME if the name value is empty.</li>
<li>UR_E_INVALID_TYPE if the type does not exist.</li>
<li>UR_E_TYPE_MISMATCH if the name already exists, but the type is different.</li>
</ul>
<p>### Undefine field </p><div class="fragment"><div class="line">int ur_undefine_field(const char *name)</div><div class="line">int ur_undefine_field_by_id(ur_field_id_t id)</div></div><!-- fragment --><p> Allows to revert a previous definition of a field by ur_define_field.</p>
<p>Frees the ID of the given field for future re-use. The ID becomes invalid after a call to this function so the field with the given name can not be accessed any more. Note that the same ID may be assigned to another field later.</p>
<p>This function is not necessary in most cases. Its only purpose is to allow a re-use of field IDs since their total count is limited to 2^16-1.</p>
<p>After this function is used, all the templates using the undefined field have to freed and created again.</p>
<p>### Create UniRec template </p><div class="fragment"><div class="line">ur_template_t *ur_create_template(const char* fields, char **errstr)</div></div><!-- fragment --><p> Creates a structure describing an UniRec template with the given set of fields and returns a pointer to it.</p>
<p>The template should be freed by ur_free_template after is not needed any more.</p>
<p>Parameters:</p><ul>
<li>"fields" - A string containing names of fields separated by commas, e.g.: "FOO,BAR,BAZ"</li>
<li>"errstr" - (output) In case of an error a pointer to the error message is returned using this parameter, if not set to NULL.</li>
</ul>
<p>Order of field names is not important, i.e. any two strings with the same set of field names but with different order are equivalent.</p>
<p>All fields MUST be previously defined, either statically by UR_FIELDS or by calls to ur_define_field.</p>
<p>If an error occurs and "errstr" is not NULL, it is set to a string with corresponding error message.</p>
<p>Returns:</p><ul>
<li>Pointer to the newly created template or NULL if an error has occurred.</li>
</ul>
<p>### Create UniRec template for usage with Libtrap </p><div class="fragment"><div class="line">ur_template_t *ur_create_input_template(int ifc, const char* fields, char **errstr)</div></div><!-- fragment --><p> Creates UniRec template and set this template to specified input interface (ifc).</p>
<p>This template will be set as a minimum set of fields to be able to receive messages. If the input interface receives superset of fields, the template will be expanded.</p>
<div class="fragment"><div class="line">ur_template_t *ur_create_output_template(int ifc, const char* fields, char **errstr)</div></div><!-- fragment --><p> Creates UniRec template and set this template to specified output interface (ifc).</p>
<p>Set of fields of this template will be set to an output interface.</p>
<div class="fragment"><div class="line">ur_template_t *ur_ctx_create_bidirectional_template(trap_ctx_t *ctx, int ifc_in, int ifc_out, const char* fields, char **errstr)</div></div><!-- fragment --><p> Creates UniRec template and set this template to specified input (ifc_in) and output (ifc_out) interface.</p>
<p>This template will be set as a minimum set of fields to be able to receive messages. If the input interface receives superset of fields, the template will be expanded and new set of fields will be set to output interface.</p>
<p>### Free UniRec template </p><div class="fragment"><div class="line">void *ur_free_template(ur_template_t *tmplt)</div></div><!-- fragment --><p> Free memory allocated for a template.</p>
<h3>Retrieve value from UniRec record.</h3>
<p>Following functions are used to retrieve certain field value from UniRec record.</p>
<p>Parameters:</p><ul>
<li>"tmplt" - Pointer to UniRec template</li>
<li>"rec" - Pointer to UniRec record, which is created using given template.</li>
<li>"field" - Identifier of a field.</li>
</ul>
<div class="fragment"><div class="line">ur_get(tmplt, rec, field)</div></div><!-- fragment --><p> This function returns value of an appropriate type of a specific field (int, uint, ...). Because of this, the field must be a symbolic constant (i.e. "F_name") not a numerical ID. It can be used just for fixed size fields (not for string and bytes).</p>
<div class="fragment"><div class="line">ur_get_ptr(tmplt, rec, field)</div></div><!-- fragment --><p> This function returns pointer to a value of an appropriate type. Because of this, the field must be a symbolic constant (i.e. "F_name") not a numerical ID. It can be used for both fixed-length and variable-length fields.</p>
<div class="fragment"><div class="line">ur_get_ptr_by_id(tmplt, rec, field)</div></div><!-- fragment --><p> This function returns void pointer to a value. Field can be symbolic constant or numerical ID. It can be used for both fixed-length and variable-length fields. (This function is used for fields defined at run-time)</p>
<div class="fragment"><div class="line">char* ur_get_var_as_str(tmplt, rec, field);</div></div><!-- fragment --><p> Function copies data of a variable-length field from UniRec record and append '\0' character. The function allocates new memory space for the string, it must be freed using <a class="el" href="example__unirec_8c.html#a898b07decc0a177549f9d553ac416305">free()</a>! Field can be symbolic constant or numerical ID.</p>
<h3>Set value to UniRec record.</h3>
<p>Following functions are used to set a value to specified field in a record.</p>
<p>Parameters:</p><ul>
<li>"tmplt" - Pointer to UniRec template</li>
<li>"rec" - Pointer to UniRec record, which is created using given template.</li>
<li>"field" - Identifier of a field.</li>
<li>"value" - Value which is copied to the record.</li>
</ul>
<div class="fragment"><div class="line">ur_set(tmplt, rec, field, value)  // field must be a symbolic constant ...</div></div><!-- fragment --><p> This function assumes value of an appropriate type of a specific field (int, uint, ...). Because of this, the field must be a symbolic constant (i.e. "F_name") not a numerical ID. It can be used just for fixed size fields (not for string and bytes).</p>
<p>To set dynamically defined field, use <a class="el" href="example__unirec_8c.html#a1be5c783827bbb7c21da30485dbf4d6f">ur_get_ptr_by_id()</a> and write to that pointer.</p>
<div class="fragment"><div class="line">ur_set_var(tmplt, rec, field, val_ptr, val_len)</div></div><!-- fragment --><p> This function is used to set variable-length fields. Field can be symbolic constant or numerical ID. For better performance use function ur_clear_varlen, before setting all variable fields in record.</p>
<p>Parameters:</p><ul>
<li>"val_ptr" - Pointer to value.</li>
<li>"val_len" - Length of a value. (length which will be copied)</li>
</ul>
<div class="fragment"><div class="line">ur_clear_varlen(tmplt, rec);</div></div><!-- fragment --><p> This function will clear all variable-length fields. It can be used for better performance of setting content to variable-length fields. Use this function before setting of all the variable-length fields. </p><div class="fragment"><div class="line">ur_set_string(tmplt, rec, field, str) //</div></div><!-- fragment --><p> Set string to the UniRec record. Value is a C-style string, length is determined automatically by strlen() ('\0' is not included in the record)</p>
<ul>
<li>"str" - Pointer to a string.</li>
</ul>
<p>### Size of a fixed-length, static field </p><div class="fragment"><div class="line">ur_get_size(field) // field must be a symbolic constant ...; for static fields only</div></div><!-- fragment --><p> Returns size of a field. Field has to be statically defined. For variable-length fields it returns -1. To get size of variable-length field use function <a class="el" href="group__urtemplate.html#gaa95364028416eca5e5741dee2533e35a" title="Get size of a variable sized field in the record. Get size of a variable-length field in the record...">ur_get_var_len()</a>.</p>
<p>### Size of variable-length field </p><div class="fragment"><div class="line">ur_get_var_len(tmplt, rec, field)</div></div><!-- fragment --><p> Returns length of a variable-length field. Field can be symbolic constant or numerical ID.</p>
<p>### Size of a fixed-length part of a record </p><div class="fragment"><div class="line">ur_rec_fixlen_size(tmplt)</div></div><!-- fragment --><p> Returns size of a fixed-length part of a record.</p>
<p>### Size of a variable-length part of a record </p><div class="fragment"><div class="line">ur_rec_varlen_size(tmplt, rec)</div></div><!-- fragment --><p> Returns size of a variable-length part of a record.</p>
<p>### Size of a record </p><div class="fragment"><div class="line">ur_rec_size(tmplt, rec)</div></div><!-- fragment --><p> Returns total size of whole UniRec record.</p>
<p>### Check template's fields </p><div class="fragment"><div class="line">ur_is_present(tmplt, field)</div></div><!-- fragment --><p> Returns non-zero if field is present, zero otherwise.</p>
<p>### Check type of a field (variable-length or fixed-length) </p><div class="fragment"><div class="line">ur_is_varlen(field)</div><div class="line">ur_is_fixlen(field)</div></div><!-- fragment --><p> Returns non-zero if field is dynamic, zero otherwise.</p>
<p>### ID of a field (dynamic or static) </p><div class="fragment"><div class="line">ur_field_id_t ur_get_id_by_name(const char *name);</div></div><!-- fragment --><p> Function returns id of a field by name of the field, or UR_E_INVALID_NAME if the name is not known.</p>
<p>### Create UniRec record </p><div class="fragment"><div class="line">void* ur_create_record(const ur_template_t *tmplt, uint16_t max_var_size);</div></div><!-- fragment --><p> Allocates memory for a record with given template. It allocates N+M bytes, where N is the size of fixed-length part of the record (inferred from template), and M is the size of variable-length, which must be provided by caller.</p>
<p>Parameters:</p><ul>
<li>"tmplt" - Pointer to UniRec template.</li>
<li>"max_var_size" - Size of variable-length part, i.e. sum of lengths of all variable- length fields. If it is not known at the time of record creation, use UR_MAX_SIZE, which allocates enough memory to hold the largest possible UniRec record (65535 bytes). Set to 0 if there are no variable-length fields in the template</li>
</ul>
<p>### Free UniRec record </p><div class="fragment"><div class="line">void ur_free_record(void *record);</div></div><!-- fragment --><p> Free memory allocated for UniRec record. You can call system <a class="el" href="example__unirec_8c.html#a898b07decc0a177549f9d553ac416305">free()</a> on the record as well.</p>
<p>### Clone record </p><div class="fragment"><div class="line">ur_clone_record(tmplt, src)</div></div><!-- fragment --><p> Function creates new UniRec record and fills it with the data given by parameter. It returns Pointer to a new UniRec record.</p>
<p>Parameters:</p><ul>
<li>"tmplt" Pointer to UniRec template</li>
<li>"src" Pointer to source record</li>
</ul>
<p>### Copy fields </p><div class="fragment"><div class="line">void ur_copy_fields(dst_tmplt, dst, src_tmplt, src);</div></div><!-- fragment --><p>Copies all fields present in both templates from src to dst.</p>
<p>The function compares src_tmplt and dst_tmplt and for each field present in both templates it sets the value of field in dst to a corresponding value in src.</p>
<p>Parameters:</p><ul>
<li>"dst_tmplt" - Pointer to destination UniRec template.</li>
<li>"dst" - Pointer to destination record. It must point to a memory of enough size.</li>
<li>"src_tmplt" - Pointer to source UniRec template.</li>
<li>"src" - Pointer to source record.</li>
</ul>
<p>### Iterate over fields of a template </p><div class="fragment"><div class="line">ur_iter_fields(tmplt, id);</div></div><!-- fragment --><p> This function can be used to iterate over all fields of a given template. It returns ID of the next field present in the template after a given ID. If ID is set to UR_ITER_BEGIN, it returns the first fields. If no more fields are present, UR_ITER_END is returned.The order of fields is given by the order in which they are defined.</p>
<p>The order of fields is given by the order in which they are defined.</p>
<p>Parameters:</p><ul>
<li>"tmplt" - Pointer to a template to iterate over.</li>
<li>"id" - Field ID returned in last iteration or UR_ITER_BEGIN to get first value.</li>
</ul>
<p>Returns ID of the next field or UR_ITER_END if no more fields are present.</p>
<p>Example usage: </p><div class="fragment"><div class="line">ur_field_id_t id = UR_ITER_BEGIN;</div><div class="line">while ((id = ur_iter_fields(tmplt, id)) != UR_ITER_END) {</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">ur_iter_fields_record_order(tmplt, id);</div></div><!-- fragment --><p>This function can be used to iterate over all fields of a given template. It returns n-th ID of a record specified by index. If the return value is UR_ITER_END. The index is higher than count of fields in the template.</p>
<p>The order of fields is given by the order in the record Parameters:</p><ul>
<li>"tmplt" Template to iterate over.</li>
<li>"id" Field ID returned in last iteration or UR_ITER_BEGIN to get first value. Returns ID of the next field or UR_ITER_END if no more fields are present.</li>
</ul>
<p>Example usage: </p><div class="fragment"><div class="line">int i = 0;</div><div class="line">while ((id = ur_iter_fields_record_order(tmplt, i++)) != UR_ITER_END) {</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
